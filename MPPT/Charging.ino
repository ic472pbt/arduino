#define LOW_SOL_WATTS 5.00         // low bulk mode limit
#define MIN_SOL_WATTS 1.00          // value of solar watts // this is 0.00 watts

void set_pwm_duty(bool solarOff) {
  if(solarOff) Timer1.pwm(PWM, 0);
  else{
    duty = min(1023, max(5, duty));        // check limits of PWM duty cyle and set to PWM_MAX
                                          // if pwm is less than PWM_MIN then set it to PWM_MIN
    Timer1.pwm(PWM, duty);
  }
} 
  
//------------------------------------------------------------------------------------------------------
// This routine is the charger state machine. It has four states on, off, bulk and float.
// It's called once each time through the main loop to see what state the charger should be in.
// The battery charger can be in one of the following four states:
// 
//  On State - this is charger state for MIN_SOL_WATTS < solar watts < LOW_SOL_WATTS. In this state is the solar 
//      watts input is too low for the bulk charging state but not low enough to go into the off state. 
//      In this state we just set the pwm = 99.9% to get the most of low amount of power available.

//  Bulk State - this is charger state for solar watts > MIN_SOL_WATTS. This is where we do the bulk of the battery
//      charging and where we run the Peak Power Tracking alogorithm. In this state we try and run the maximum amount
//      of current that the solar panels are generating into the battery.

//  Float State - As the battery charges it's voltage rises. When it gets to the MAX_BAT_VOLTS we are done with the 
//      bulk battery charging and enter the battery float state. In this state we try and keep the battery voltage
//      at MAX_BAT_VOLTS by adjusting the pwm value. If we get to pwm = 100% it means we can't keep the battery 
//      voltage at MAX_BAT_VOLTS which probably means the battery is being drawn down by some load so we need to back
//      into the bulk charging mode.

//  Off State - This is state that the charger enters when solar watts < MIN_SOL_WATTS. The charger goes into this
//      state when there is no more power being generated by the solar panels. The MOSFETs are turned
//      off in this state so that power from the battery doesn't leak back into the solar panel. 
//------------------------------------------------------------------------------------------------------
void Charging_Algorithm(float sol_volts, unsigned long currentTime) { 
  static bool startTracking = true;
  static int 
    voltageInputPrev = 0,
    delta = 10;
  static byte 
    flip = 1,
    stepSize = 128;  
  static unsigned long
    rawPowerPrev   = 0,
    lastTrackingTime   = 0,
    lastMpptREportTime = 0;
  // rawPowerOld        = 0;    // solar watts from previous time through ppt routine 
  
  if(ERR>0){
    charger_state = off;
    duty-=100;
    set_pwm_duty(true);
    return;
  }else if (REC==1){ // wait for recovery from low solar voltage (starting a new day)
    if(solarV > batteryV + 1.0){
      REC=0;
//      while(ADS.isBusy()){}
//      inCurrentOffset = ADS.readADC(CURRENT_IN_SENSOR) + 2;   // zero current offset
//      ADS.requestADC(currentADCpin);    
      duty=300;  
      charger_state = bat_float;
      StoreHarvestingData(currentTime);
      todayWh = 0.0; todayAh = todayWh;
      todayOutWh = 0.0; todayOutAh = todayWh;
    }else  return;                                 // there is error or waiting recovery
  }
  
    static int off_count = OFF_NUM;
    if(absorptionAccTime >= ABSORPTION_TIME_LIMIT) {
      floatVoltage = BATT_FLOAT;
      floatVoltageRaw = BATT_FLOAT_RAW;         
    }

    switch (charger_state) {
      case on:                                    
        mpptReached = 0;
        if (solarV + 0.2 < batteryV) {                      // if watts input from the solar panel is less than
          charger_state = off;                                // the minimum solar watts then 
          off_count = OFF_NUM;                                // go to the charger off state
          set_pwm_duty(true); 
          /* Serial.print(solarV); Serial.print(' ');
          Serial.print(batteryV);
          Serial.println("go off");*/
        }
        else if (rawBatteryV > (BATT_FLOAT_RAW - 7)) {            // else if the battery voltage has gotten above the float
          charger_state = bat_float;                          // battery float voltage go to the charger battery float state
          /*Serial.print(batteryV); Serial.print(' ');
          Serial.print(BATT_FLOAT);
          Serial.println("go float");*/
        }
        else if (sol_watts < LOW_SOL_WATTS) {                 // else if the solar input watts is less than low solar watts
          duty = 1023;                                      // it means there is not much power being generated by the solar panel
          set_pwm_duty(false);                                 // so we just set the pwm = 100% so we can get as much of this power as possible
          /*Serial.print(batteryV); Serial.print(' ');
          Serial.println("go on");*/
        }                                                     // and stay in the charger on state
        else {              
          // else if we are making more power than low solar watts figure out what the pwm
          charger_state = bulk;
          startTracking = true;
          duty = 300;
          set_pwm_duty(false);
          // stepSize = 16; flip = 1;
          /* transitionFromOnToBulk = true;
          // value should be and change the charger to bulk state 
          Serial.print(batteryV); Serial.print(' ');
          Serial.println("go bulk");*/
        }
        break;      
      case bulk:
        if (solarV + 0.2 < batteryV) {                        // if watts input from the solar panel is less than
          charger_state = off;                                // the minimum solar watts then it is getting dark so
          off_count = OFF_NUM;                                // go to the charger off state
          set_pwm_duty(true); 
        }
        else if (batteryV > floatVoltage + tempCompensation) {
          controlFloat = true;                                              // else if the battery voltage has gotten above the float
          charger_state = bat_float;                          // battery float voltage go to the charger battery float state
        }
        else if (sol_watts < LOW_SOL_WATTS) {                 // else if the solar input watts is less than low solar watts
          charger_state = on;                                 // it means there is not much power being generated by the solar panel
          duty = 1023;
          // so go to charger on state
          set_pwm_duty(false);
          /* Serial.print(sol_watts); Serial.print(' ');
          Serial.println("go on");*/
        }
        else {                                    // this is where we do the Peak Power Tracking ro Maximum Power Point algorithm
          unsigned long solarPower = (unsigned long)rawCurrentIn * rawBatteryV;
          if(mpptReached == 1 || startTracking){
            if(currentTime - lastTrackingTime > 30000 || startTracking){
               // do perturbation
              stepSize = 16;
              delta = (2 * flip - 1) * stepSize;
              duty += delta;
              lastTrackingTime = currentTime;
              mpptReached = 0; // ! reset MPPT
              rawPowerPrev = solarPower;   
              voltageInputPrev = rawSolarV;           
              startTracking = false;
            }
          }else{
            Serial.print("power before: "); Serial.print(rawPowerPrev); 
            Serial.print("power after: "); Serial.println(solarPower); 
            Serial.print("voltage before: "); Serial.print(voltageInputPrev); 
            Serial.print("voltage after: "); Serial.print(rawSolarV);
            Serial.print("pwm: "); Serial.print(duty); 
            Serial.print("delta: "); Serial.println(delta); 
           if(solarPower > rawPowerPrev){
                duty += delta;
                rawPowerPrev = solarPower;
           } else {
                duty -= delta;
                delta /= 2;
                if(delta == 0){                                   //  MP MV ; MPP Reached -                                           
                  flip = 1 - flip;
                  // stepSize /= 2;  // varry step size
                  // if(stepSize == 0) stepSize = 128;               
                  mpptReached = 1; // ! indicate MPPT reached
                  lastMpptREportTime = currentTime;
                } 
              }
          }                    
          set_pwm_duty(false);                   // set pwm duty cycle to pwm value
        }
        break;
      case bat_float:  
        mpptReached = 0;
        if(rawBatteryV > floatVoltageRaw + tempCompensationRaw - 25){
          if(absorptionStartTime == 0) absorptionStartTime = currentTime;
          else if(absorptionStartTime > 10000) {absorptionAccTime += currentTime - absorptionStartTime; absorptionStartTime = currentTime;}
        }
        if (solarV + 0.2< batteryV) {                         // if watts input from the solar panel is less than
          charger_state = off;                                // the minimum solar watts then it is getting dark so
          off_count = OFF_NUM;                                // go to the charger off state  
          set_pwm_duty(true);         
        }        
        else if (rawBatteryV > floatVoltageRaw + tempCompensationRaw) {                    // If we've charged the battery above the float voltage                   
          int delta = (batteryV - (floatVoltage + tempCompensation)) / 0.02;
          Serial.print(batteryV);Serial.print("decrease "); Serial.println(delta);
          duty -= delta;                                      // down
          set_pwm_duty(false);                                     // write the PWM
        }
        else if (rawBatteryV < floatVoltageRaw + tempCompensationRaw) {                    // else if the battery voltage is less than the float voltage - 0.1
          int delta = 2; // (batteryV - (floatVoltage + tempCompensation)) / 0.01;
          Serial.print(batteryV);Serial.print("increase "); Serial.println(delta);
          duty += delta;                                              // up
          set_pwm_duty(false);                                     
          if (rawBatteryV < floatVoltageRaw + tempCompensationRaw - 40){ //(floatVoltage + tempCompensation - 0.6)) {               // if the voltage drops because of added load,
            absorptionAccTime += currentTime - absorptionStartTime;
            absorptionStartTime = 0;
            charger_state = bulk;                               // switch back into bulk state to keep the voltage up
            startTracking = true;
            stepSize = 8; // flip = 1;
          }
        }
        break;
      case off:                                               // when we jump into the charger off state, off_count is set with OFF_NUM
        mpptReached = 0;
        bool solarOff = true;
        if (off_count > 0) {                                  // this means that we run through the off state OFF_NUM of times with out doing
          off_count--;                                        // anything, this is to allow the battery voltage to settle down to see if the  
        }                                                     // battery has been disconnected
        else if ((batteryV > floatVoltage + tempCompensation) && (sol_volts > batteryV)) {
          charger_state = bat_float;                          // if battery voltage is still high and solar volts are high
          solarOff = false;
        }    
        else if ((batteryV > LVD) && (batteryV < floatVoltage + tempCompensation) && (sol_volts > batteryV)) {
          charger_state = bulk;
          solarOff = false;
          duty=300;
        }
        set_pwm_duty(solarOff);
        break;
      default:
        solarOff = true;
        break;
    }
}
